# Розрахунково-графічна робота
## Шаблони проектування
**Мета роботи:** Вивчення стандартних ситуацій у процесі розробки складних програмних проектів та застосування шаблонів проектування (Design patterns) для їх вирішення.  

**Варіант 19**  
Creational pattern - Lazy Initialization  
Structural pattern - Proxy  
Behavioral pattern - Observer  
Concurrency pattern - Monitor 

| № | Вимоги до роботи  | Бали % | Що виконано| 
---| ------------- | ------------- |---|
1| Текстовий опис шаблону, його основних складових частин, їх призначення (з посиланням на першоджерело! )  | 5  | +
2| UML модель шаблону у вигляді Mermaid діаграми  | 5  | +
3|Програмний проект на С# , що демонструє - специфіку шаблону проектування (кожен шаблон окремо) | 5  | +
4|Реалізація шаблону проектування додатковою (будь-якою) мовою програмування | 5  | +
5| Створення шаблону проектування (design pattern) у вигляді шаблону проекту або елемента (project / item template) для Visual Studio (zip -файл)| 5  | -
## Lazy Initialization
[Lazy Initialization ](https://www.codingdrills.com/tutorial/design-patterns-tutorial/lazy-initialization-pattern)  
Паттерн Lazy Initialization використовується, коли ви хочете відкласти створення об'єкта до моменту його першої потреби. Цей підхід може допомогти покращити продуктивність, уникнувши непотрібного створення об'єктів та оптимізуючи використання ресурсів.  

**Призначення та використання**
Застосовується в наступних випадках:
- Високі витрати на створення об'єкта (пам'яті та часу)
- Зменшення часу старту програми. Коли потрібно зменшити час завантаження програми, відкладаючи ініціалізацію важких об'єктів до моменту їх використання.
- Контроль над ініціалізацією. Коли необхідно забезпечити контроль над моментом ініціалізації об'єкта для уникнення зайвих витрат.

**Динамічна модель**  

![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/ecdd1595-e879-4c84-babb-78147fa4c717)  

**Статична модель**  
![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/3a188c4e-7de3-405a-b5d2-38bebd7a054c)

## Proxy 
[Proxy](https://www.codingdrills.com/tutorial/design-patterns-tutorial/proxy-pattern)  
Патерн проектування Proxy (Замісник) є одним з таких патернів, що має на меті контроль доступу до об'єктів, спрощення складних систем і підвищення продуктивності шляхом надання сурогатного або заповнювального об'єкта.  

**Призначення та використання**  
Патерн Proxy  використовується для створення сурогатного або заповнювального об'єкта, який контролює доступ до іншого об'єкта.  
Основні цілі цього патерну:
- Контроль доступу. Може обмежувати доступ до ресурсу.
- Спрощення взаємодії. Може представляти складний об'єкт, спрощуючи його використання для користувача.
- Підвищення продуктивності. може кешувати результати запитів до реального об'єкта або виконувати оптимізації для зменшення витрат ресурсів.
**Динамічна модель**

![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/904d7b60-0306-4096-821a-332f94e8a5d7)  

**Статична модель**

![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/ec458734-abb7-4f85-a22b-7966b248a29e)

## Observer
[Observer](https://www.codingdrills.com/tutorial/design-patterns-tutorial/observer-pattern)  
Патерн проектування Observer (Спостерігач) є поведінковим патерном, який дозволяє об'єкту, відомому як суб'єкт (subject), підтримувати список залежних об'єктів, відомих як спостерігачі (observers), і автоматично повідомляти їх про будь-які зміни стану. Цей патерн сприяє слабкому зв'язку між об'єктами, забезпечуючи, щоб зміни в одному об'єкті не впливали безпосередньо на інші об'єкти.  

**Призначення та використання**  
Патерн проектування Observer (Спостерігач) призначений для створення механізму підписки, який дозволяє одним об'єктам (спостерігачам) отримувати повідомлення про зміни стану інших об'єктів (суб'єктів).  
Основні цілі цього патерну:
- Автоматично інформувати спостерігачів про будь-які зміни стану суб'єкта.
- Сприяти слабкому зв'язуванню між суб'єктом і спостерігачами, що забезпечує гнучкість і зручність у підтримці та розширенні коду.

**Динамічна модель**  

![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/1a4f7fa9-18e6-4ce0-b6db-6c6a617bec1d)  

**Статична модель**  

![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/27bb91d2-1225-4e31-8214-f27d8ee5e9aa)


## Monitor
[Monitor](https://www.linkedin.com/pulse/understanding-concurrency-lock-monitor-mutex-c-roman-fairushyn-51aef)  
Monitor використовується для координації доступу до спільних ресурсів в багатопотоковому середовищі. Він корисний для складних сценаріїв синхронізації, де потрібна точна координація між потоками для уникнення гонок за ресурсами або нестабільних умов. 

**Призначення та використання**  

Використовується для управління доступом до критичних секцій коду, забезпечуючи безпеку та взаємовиключення між потоками. Зазвичай монітор включає в себе можливість явного заблокування і розблокування, а також механізм очікування і сигналізації, щоб потоки могли чекати на певні умови або події. 
**Динамічна модель**  

![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/5e6b88c4-a9ba-4a1c-a445-e0d97301c392)  

**Статична  модель**  

![image](https://github.com/JuliaSylenok/Lab_RGR/assets/149322465/4ed60afa-03fe-446d-8d87-baf6c2960d93)

